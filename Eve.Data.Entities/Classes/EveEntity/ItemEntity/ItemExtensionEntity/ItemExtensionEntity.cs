//-----------------------------------------------------------------------
// <copyright file="ItemExtensionEntity.cs" company="Jeremy H. Todd">
//     Copyright © Jeremy H. Todd 2011
// </copyright>
//-----------------------------------------------------------------------
namespace Eve.Data.Entities
{
  using System.Diagnostics.CodeAnalysis;

  using FreeNet.Data.Entity;

  /// <summary>
  /// The base class for entities which contain extra information attached
  /// to certain <see cref="ItemEntity" /> objects.
  /// </summary>
  /// <remarks>
  /// <para>
  /// The EVE database contains information about a very large number of
  /// in-game entities in the <c>invItems</c> table.  Many different types
  /// of information is stored in this table: information about agents, 
  /// constellations, solar systems, celestial objects, stargates, you name it.
  /// The records in this table have a set of core columns that apply to all
  /// rows, but there is also a series of related tables (e.g. <c>agtAgents</c>,
  /// <c>mapConstellations</c>, etc.) that contain extra information 
  /// about certain rows.
  /// </para>
  /// <para>
  /// Normally, we would use Table-Per-AttributeType inheritance to model this
  /// relationship, with a base <c>ItemEntity</c> class, and then
  /// derived <c>AgentEntity</c>, <c>ConstellationEntity</c>, etc.
  /// classes, each pulling additional data from one of those related tables.
  /// </para>
  /// <para>
  /// However, there are two problems with this approach.  The first (and
  /// largest) is that the sheer number of rows and derived types makes
  /// the SQL queries generated by the Entity Framework slow to the
  /// point of unusability.  The second is that the key column names and
  /// types sometimes vary between ancillary tables, meaning that some
  /// manual massaging of the database schema is necessary to make things
  /// work properly.
  /// </para>
  /// <para>
  /// With that in mind, I've adopted a compromise approach.  The main
  /// <see cref="ItemEntity" /> class now stands alone, with no derived
  /// classes.  The related types (<c>AgentEntity</c>, <c>ConstellationEntity</c>,
  /// etc.) now derive from this <c>EvenItemExtensionEntity</c> class,
  /// and have no explicitly-defined relationship to the <c>invItems</c> table.
  /// <c>ItemEntity</c> now has a series of navigation properties (e.g. <c>AgentInfo</c>,
  /// <c>ConstellationInfo</c>, etc.) that lazily-load information from those
  /// ancillary tables, along with boolean properties <c>IsAgent</c>,
  /// <c>IsConstellation</c>, etc. that determine the item's type based on its ID value,
  /// and let consumers know which of those navigation properties can be used.
  /// </para>
  /// <para>
  /// The adapter classes (derived from <see cref="Item" />) hide the complication and
  /// present a simple, flat interface to the developer, while the entity's navigation
  /// properties still allow LINQ queries against the ancillary tables, albeit with
  /// slightly more complicated syntax.  The biggest benefit, though, is the 
  /// performance increase, which is vital.
  /// </para>
  /// </remarks>
  public abstract partial class ItemExtensionEntity : EveEntity
  {
    /* Constructors */

    /// <summary>
    /// Initializes a new instance of the ItemExtensionEntity class.
    /// </summary>
    public ItemExtensionEntity() : base()
    {
    }
  }
}